import Foundation

// MARK: - Data Models

/// A tax-related update from the IRS or regulatory sources
struct TaxUpdate: Identifiable {
    let id = UUID()
    let effectiveDate: Date
    let description: String
    let impact: TaxImpact
    let source: String
    let url: URL?
}

/// Describes the specific nature of a tax change
enum TaxImpact {
    case mileageRateChange(oldRate: Double, newRate: Double)
    case bracketChange(description: String)
    case thresholdChange(name: String, oldValue: Double, newValue: Double)
    case deadlineChange(quarter: String, newDate: Date)
    case newRule(description: String)
}

/// Real-time gas price data with cost-per-mile calculation for gig drivers
struct GasPriceData {
    let nationalAverage: Double
    let stateAverage: Double?
    let weeklyChange: Double     // percent change
    let monthlyChange: Double    // percent change
    let fetchedAt: Date
    let costPerMile: Double      // Calculated: avg price / avg MPG for gig vehicles
}

/// Benchmark data for a specific gig platform metric
struct GigBenchmark: Identifiable {
    let id = UUID()
    let platform: String
    let metric: String           // "hourly_rate", "daily_earnings", "fee_rate"
    let nationalMedian: Double
    let percentile25: Double
    let percentile75: Double
    let lastUpdated: Date
    let source: String
}

/// A macroeconomic indicator relevant to gig workers
struct EconomicIndicator: Identifiable {
    let id = UUID()
    let name: String             // "CPI", "Unemployment Rate", "Consumer Spending"
    let value: Double
    let previousValue: Double
    let change: Double
    let relevance: String        // "Higher CPI means your expenses are rising faster"
    let lastUpdated: Date
}

/// An insight generated by comparing the user's data against external market data
struct ContextualInsight: Identifiable {
    let id = UUID()
    let title: String
    let detail: String
    let icon: String
    let category: Category
    let dataSource: String
    let confidence: Double       // 0.0–1.0: how fresh/reliable the external data is

    enum Category: String {
        case benchmark = "Benchmark"
        case marketTrend = "Market Trend"
        case taxAlert = "Tax Alert"
        case costAlert = "Cost Alert"
        case opportunity = "Opportunity"
    }
}

// MARK: - Market Intelligence Service

/// Fetches real-world external data from public APIs and produces contextual insights
/// by comparing the user's personal financial data against market benchmarks.
///
/// Data sources:
/// - **EIA** (Energy Information Administration): National and state gas prices
/// - **IRS**: Mileage rates, tax brackets, 1099-K thresholds, quarterly deadlines
/// - **BLS** (Bureau of Labor Statistics): Gig economy wage benchmarks
/// - **FRED** (Federal Reserve Economic Data): CPI, unemployment, consumer spending
///
/// All data is cached for 24 hours. When the network is unavailable, the service falls
/// back to hardcoded defaults derived from publicly available 2026 data.
@Observable
@MainActor
final class MarketIntelligenceService: @unchecked Sendable {

    // MARK: - Published State

    /// Current gas price data (national and optional state-level)
    private(set) var gasPrices: GasPriceData?

    /// Recent IRS and tax-related updates
    private(set) var taxUpdates: [TaxUpdate] = []

    /// Platform earnings benchmarks from BLS and public reports
    private(set) var benchmarks: [GigBenchmark] = []

    /// Macroeconomic indicators relevant to gig workers
    private(set) var economicIndicators: [EconomicIndicator] = []

    /// Timestamp of the last successful data refresh
    private(set) var lastRefresh: Date?

    /// Whether any fetch operation is currently in progress
    private(set) var isLoading = false

    // MARK: - Configuration

    /// Cache TTL: 24 hours
    private let cacheInterval: TimeInterval = 86_400

    /// Average fuel economy assumed for gig vehicles (MPG)
    private let averageGigVehicleMPG: Double = 25.0

    // MARK: - API Endpoints
    //
    // EIA (Energy Information Administration) — gas prices:
    //   https://api.eia.gov/v2/petroleum/pri/gnd/data/
    //   Free API key: https://www.eia.gov/opendata/register.php
    //
    // FRED (Federal Reserve Economic Data) — economic indicators:
    //   https://api.stlouisfed.org/fred/series/observations
    //   Free API key: https://fred.stlouisfed.org/docs/api/api_key.html
    //   Series IDs: CPIAUCSL (CPI), UNRATE (Unemployment), PCE (Consumer Spending)
    //
    // BLS (Bureau of Labor Statistics) — wage data:
    //   https://api.bls.gov/publicAPI/v2/timeseries/data/
    //   Free, no key required for v1 (25 requests/day)
    //   Series: CEU6562110008 (ride-hailing hourly earnings)
    //
    // IRS — official announcements:
    //   https://www.irs.gov/newsroom (RSS feed)
    //   Standard mileage rates, bracket adjustments, 1099-K thresholds

    private let eiaBaseURL = "https://api.eia.gov/v2/petroleum/pri/gnd/data/"
    private let fredBaseURL = "https://api.stlouisfed.org/fred/series/observations"
    private let blsBaseURL = "https://api.bls.gov/publicAPI/v2/timeseries/data/"

    // MARK: - API Keys
    // API keys loaded from Secrets.xcconfig → Info.plist at build time
    // Free government APIs — no billing, no rate-limit concerns for single-user app.
    private let eiaAPIKey: String = Bundle.main.infoDictionary?["EIA_API_KEY"] as? String ?? ""
    private let fredAPIKey: String = Bundle.main.infoDictionary?["FRED_API_KEY"] as? String ?? ""

    // MARK: - URLSession

    private let session: URLSession = {
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 15
        config.timeoutIntervalForResource = 30
        config.waitsForConnectivity = false
        return URLSession(configuration: config)
    }()

    // MARK: - Singleton

    /// Shared instance for SwiftUI environment injection
    static let shared = MarketIntelligenceService()

    private init() {}

    // MARK: - Refresh

    /// Refreshes all data sources if the cache is stale (older than 24 hours).
    ///
    /// Fetches gas prices, tax updates, gig benchmarks, and economic indicators
    /// in parallel. Partial failures are tolerated — cached data from successful
    /// fetches is retained even if other sources fail.
    func refreshIfNeeded(stateCode: String = "US") async {
        // Skip if cache is still fresh
        if let lastRefresh, Date.now.timeIntervalSince(lastRefresh) < cacheInterval {
            return
        }

        isLoading = true
        defer { isLoading = false }

        // Fetch all data sources concurrently using async let
        async let gasResult = fetchGasPrices(stateCode: stateCode)
        async let taxResult = fetchTaxUpdates()
        async let benchmarkResult = fetchGigBenchmarks()
        async let indicatorResult = fetchEconomicIndicators()

        // Await all results and update state
        let gas = await gasResult
        let taxes = await taxResult
        let benchmarkData = await benchmarkResult
        let indicators = await indicatorResult

        if let gas {
            gasPrices = gas
        }
        if !taxes.isEmpty {
            taxUpdates = taxes
        }
        if !benchmarkData.isEmpty {
            benchmarks = benchmarkData
        }
        if !indicators.isEmpty {
            economicIndicators = indicators
        }

        lastRefresh = .now
    }

    /// Forces a full refresh regardless of cache state.
    func forceRefresh(stateCode: String = "US") async {
        lastRefresh = nil
        await refreshIfNeeded(stateCode: stateCode)
    }

    // MARK: - Gas Prices

    /// Fetches current gas price data from the EIA API.
    ///
    /// - Parameter stateCode: Two-letter state code (e.g. "CA", "TX"). Pass "US" for national only.
    /// - Returns: Gas price data with cost-per-mile calculation, or fallback defaults if the API is unavailable.
    ///
    /// API: `https://api.eia.gov/v2/petroleum/pri/gnd/data/`
    /// Requires a free API key from https://www.eia.gov/opendata/register.php
    func fetchGasPrices(stateCode: String = "US") async -> GasPriceData? {
        // Attempt live fetch if we have an API key
        if !eiaAPIKey.isEmpty {
            do {
                var components = URLComponents(string: eiaBaseURL)
                components?.queryItems = [
                    URLQueryItem(name: "api_key", value: eiaAPIKey),
                    URLQueryItem(name: "frequency", value: "weekly"),
                    URLQueryItem(name: "data[0]", value: "value"),
                    URLQueryItem(name: "facets[product][]", value: "EPM0"),      // Regular gasoline
                    URLQueryItem(name: "facets[duoarea][]", value: "NUS"),        // National
                    URLQueryItem(name: "sort[0][column]", value: "period"),
                    URLQueryItem(name: "sort[0][direction]", value: "desc"),
                    URLQueryItem(name: "length", value: "5")
                ]

                guard let url = components?.url else { return fallbackGasPrices(stateCode: stateCode) }

                let (data, response) = try await session.data(from: url)

                guard let httpResponse = response as? HTTPURLResponse,
                      httpResponse.statusCode == 200 else {
                    return fallbackGasPrices(stateCode: stateCode)
                }

                return parseEIAResponse(data: data, stateCode: stateCode)

            } catch {
                // Network error — fall through to fallback
            }
        }

        return fallbackGasPrices(stateCode: stateCode)
    }

    /// Parses the EIA JSON response into a `GasPriceData` value.
    private func parseEIAResponse(data: Data, stateCode: String) -> GasPriceData? {
        // EIA response structure:
        // { "response": { "data": [ { "period": "2026-W07", "value": "3.45", ... } ] } }
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let responseObj = json["response"] as? [String: Any],
              let dataArray = responseObj["data"] as? [[String: Any]],
              let latest = dataArray.first,
              let priceString = latest["value"] as? String,
              let price = Double(priceString) else {
            return fallbackGasPrices(stateCode: stateCode)
        }

        // Calculate weekly and monthly changes from historical data points
        let previousWeekPrice = dataArray.count > 1
            ? (Double((dataArray[1]["value"] as? String) ?? "") ?? price)
            : price
        let previousMonthPrice = dataArray.count > 4
            ? (Double((dataArray[4]["value"] as? String) ?? "") ?? price)
            : price

        let weeklyChange = previousWeekPrice > 0
            ? ((price - previousWeekPrice) / previousWeekPrice) * 100.0
            : 0.0
        let monthlyChange = previousMonthPrice > 0
            ? ((price - previousMonthPrice) / previousMonthPrice) * 100.0
            : 0.0

        let costPerMile = price / averageGigVehicleMPG

        return GasPriceData(
            nationalAverage: price,
            stateAverage: stateCode != "US" ? stateGasPriceEstimate(national: price, stateCode: stateCode) : nil,
            weeklyChange: weeklyChange,
            monthlyChange: monthlyChange,
            fetchedAt: .now,
            costPerMile: costPerMile
        )
    }

    /// Returns fallback gas price data based on 2026 national averages.
    ///
    /// Source: EIA Short-Term Energy Outlook — average regular gasoline ~$3.40/gallon nationally (2026 projection).
    private func fallbackGasPrices(stateCode: String) -> GasPriceData {
        let nationalAvg = 3.40
        let costPerMile = nationalAvg / averageGigVehicleMPG  // ~$0.136/mile

        return GasPriceData(
            nationalAverage: nationalAvg,
            stateAverage: stateCode != "US" ? stateGasPriceEstimate(national: nationalAvg, stateCode: stateCode) : nil,
            weeklyChange: 0.0,
            monthlyChange: 0.0,
            fetchedAt: .now,
            costPerMile: costPerMile
        )
    }

    /// Estimates state-level gas prices by applying a multiplier to the national average.
    ///
    /// Multipliers are based on historical state-vs-national price differentials from EIA data.
    private func stateGasPriceEstimate(national: Double, stateCode: String) -> Double {
        let stateMultipliers: [String: Double] = [
            "CA": 1.35, "HI": 1.30, "WA": 1.20, "OR": 1.18, "NV": 1.15,
            "AK": 1.12, "IL": 1.10, "PA": 1.08, "NY": 1.08, "CT": 1.07,
            "MA": 1.06, "NJ": 1.05, "MD": 1.04, "MI": 1.02, "CO": 1.02,
            "AZ": 1.01, "VA": 1.00, "FL": 0.99, "NC": 0.98, "GA": 0.97,
            "OH": 0.97, "IN": 0.96, "TN": 0.95, "MO": 0.94, "KY": 0.94,
            "SC": 0.93, "AL": 0.93, "MS": 0.92, "AR": 0.92, "LA": 0.91,
            "OK": 0.91, "KS": 0.92, "TX": 0.90, "MN": 0.98, "WI": 0.97,
            "IA": 0.95, "NE": 0.96, "SD": 0.95, "ND": 0.96, "MT": 1.00,
            "WY": 0.98, "NM": 0.98, "ID": 1.02, "UT": 1.00, "ME": 1.05,
            "VT": 1.06, "NH": 1.04, "RI": 1.05, "DE": 1.02, "WV": 0.96,
            "DC": 1.08
        ]

        let multiplier = stateMultipliers[stateCode] ?? 1.0
        return national * multiplier
    }

    // MARK: - Tax Updates

    /// Fetches recent tax updates relevant to gig workers.
    ///
    /// Attempts to parse the IRS newsroom RSS feed for changes to mileage rates,
    /// bracket adjustments, 1099-K thresholds, and quarterly deadlines.
    ///
    /// API: IRS RSS feed at `https://www.irs.gov/newsroom/feed`
    /// Fallback: Hardcoded 2026 tax constants from TaxEngine.
    func fetchTaxUpdates() async -> [TaxUpdate] {
        // Attempt IRS RSS feed
        if let url = URL(string: "https://www.irs.gov/newsroom/feed") {
            do {
                let (data, response) = try await session.data(from: url)

                guard let httpResponse = response as? HTTPURLResponse,
                      httpResponse.statusCode == 200 else {
                    return fallbackTaxUpdates()
                }

                let parsed = parseIRSFeed(data: data)
                return parsed.isEmpty ? fallbackTaxUpdates() : parsed

            } catch {
                // Network error — fall through to fallback
            }
        }

        return fallbackTaxUpdates()
    }

    /// Parses the IRS RSS/XML feed for gig-worker-relevant announcements.
    ///
    /// Looks for keywords: "mileage", "standard rate", "1099-K", "estimated tax",
    /// "self-employment", "quarterly", "bracket".
    private func parseIRSFeed(data: Data) -> [TaxUpdate] {
        // Simple keyword-based XML parsing for RSS <item> elements.
        // A production app would use XMLParser for robust handling.
        guard let xmlString = String(data: data, encoding: .utf8) else { return [] }

        var updates: [TaxUpdate] = []
        let gigKeywords = [
            "mileage", "standard rate", "1099-K", "1099K",
            "estimated tax", "self-employment", "quarterly",
            "bracket", "gig", "independent contractor"
        ]

        // Split by <item> tags
        let items = xmlString.components(separatedBy: "<item>")
        for item in items.dropFirst().prefix(20) {
            let title = extractXMLValue(tag: "title", from: item)
            let description = extractXMLValue(tag: "description", from: item)
            let link = extractXMLValue(tag: "link", from: item)
            let pubDate = extractXMLValue(tag: "pubDate", from: item)

            let combined = (title + " " + description).lowercased()
            let isRelevant = gigKeywords.contains { combined.contains($0) }

            guard isRelevant, !title.isEmpty else { continue }

            let impact = classifyTaxImpact(title: title, description: description)
            let date = parseRSSDate(pubDate) ?? .now

            updates.append(TaxUpdate(
                effectiveDate: date,
                description: title,
                impact: impact,
                source: "IRS Newsroom",
                url: URL(string: link)
            ))
        }

        return updates
    }

    /// Extracts the text content between matching XML open/close tags.
    private func extractXMLValue(tag: String, from xml: String) -> String {
        guard let startRange = xml.range(of: "<\(tag)>"),
              let endRange = xml.range(of: "</\(tag)>"),
              startRange.upperBound < endRange.lowerBound else {
            // Try CDATA format: <tag><![CDATA[...]]></tag>
            guard let cdataStart = xml.range(of: "<\(tag)><![CDATA["),
                  let cdataEnd = xml.range(of: "]]></\(tag)>"),
                  cdataStart.upperBound < cdataEnd.lowerBound else {
                return ""
            }
            return String(xml[cdataStart.upperBound..<cdataEnd.lowerBound])
        }
        return String(xml[startRange.upperBound..<endRange.lowerBound])
    }

    /// Parses an RFC 2822 date string (common in RSS feeds).
    private func parseRSSDate(_ dateString: String) -> Date? {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.dateFormat = "EEE, dd MMM yyyy HH:mm:ss Z"
        return formatter.date(from: dateString)
    }

    /// Classifies an IRS announcement into a specific `TaxImpact` type based on keywords.
    private func classifyTaxImpact(title: String, description: String) -> TaxImpact {
        let combined = (title + " " + description).lowercased()

        if combined.contains("mileage") || combined.contains("standard rate") {
            return .mileageRateChange(oldRate: 0.67, newRate: 0.70)
        } else if combined.contains("bracket") {
            return .bracketChange(description: title)
        } else if combined.contains("1099-k") || combined.contains("1099k") {
            return .thresholdChange(name: "1099-K Reporting", oldValue: 20_000, newValue: 5_000)
        } else if combined.contains("deadline") || combined.contains("quarterly") {
            return .deadlineChange(quarter: "Q1 2026", newDate: Date(timeIntervalSince1970: 1_776_556_800)) // Apr 15, 2026
        } else {
            return .newRule(description: title)
        }
    }

    /// Returns hardcoded tax updates based on known 2026 IRS constants.
    ///
    /// These match the values in `TaxEngine.TaxConstants` and serve as reliable
    /// fallbacks when the IRS feed is unavailable.
    private func fallbackTaxUpdates() -> [TaxUpdate] {
        let calendar = Calendar.current
        let year = calendar.component(.year, from: .now)

        return [
            TaxUpdate(
                effectiveDate: calendar.date(from: DateComponents(year: year, month: 1, day: 1)) ?? .now,
                description: "IRS standard mileage rate for \(year): $0.70 per mile",
                impact: .mileageRateChange(oldRate: 0.67, newRate: TaxEngine.TaxConstants.mileageRate),
                source: "IRS Revenue Procedure (Fallback)",
                url: URL(string: "https://www.irs.gov/tax-professionals/standard-mileage-rates")
            ),
            TaxUpdate(
                effectiveDate: calendar.date(from: DateComponents(year: year, month: 1, day: 1)) ?? .now,
                description: "1099-K reporting threshold lowered to $5,000 (phased rollout from $20,000)",
                impact: .thresholdChange(
                    name: "1099-K Reporting Threshold",
                    oldValue: 20_000,
                    newValue: TaxEngine.TaxConstants.form1099KThreshold
                ),
                source: "IRS Notice (Fallback)",
                url: URL(string: "https://www.irs.gov/payments/general-faqs-on-new-payment-card-reporting-requirements")
            ),
            TaxUpdate(
                effectiveDate: calendar.date(from: DateComponents(year: year, month: 4, day: 15)) ?? .now,
                description: "Q1 \(year) estimated tax payment deadline: April 15",
                impact: .deadlineChange(
                    quarter: "Q1 \(year)",
                    newDate: calendar.date(from: DateComponents(year: year, month: 4, day: 15)) ?? .now
                ),
                source: "IRS (Fallback)",
                url: URL(string: "https://www.irs.gov/faqs/estimated-tax")
            ),
            TaxUpdate(
                effectiveDate: calendar.date(from: DateComponents(year: year, month: 1, day: 1)) ?? .now,
                description: "Self-employment tax rate: 15.3% (12.4% Social Security + 2.9% Medicare)",
                impact: .newRule(description: "SE tax rate unchanged at 15.3% for \(year)"),
                source: "IRS (Fallback)",
                url: URL(string: "https://www.irs.gov/businesses/small-businesses-self-employed/self-employment-tax-social-security-and-medicare-taxes")
            )
        ]
    }

    // MARK: - Gig Benchmarks

    /// Fetches gig economy earnings benchmarks from the BLS API and public data.
    ///
    /// API: `https://api.bls.gov/publicAPI/v2/timeseries/data/`
    /// Series: CEU6562110008 (Transportation & Warehousing hourly earnings)
    ///
    /// Falls back to hardcoded benchmarks derived from published gig economy surveys
    /// (published gig economy surveys, BLS Occupational Employment Statistics).
    func fetchGigBenchmarks() async -> [GigBenchmark] {
        // Attempt BLS API call
        if let url = URL(string: blsBaseURL) {
            do {
                var request = URLRequest(url: url)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")

                // Request transportation & warehousing hourly earnings
                let body: [String: Any] = [
                    "seriesid": ["CEU6562110008"],  // Ride-hailing services
                    "startyear": "2025",
                    "endyear": "2026"
                ]
                request.httpBody = try JSONSerialization.data(withJSONObject: body)

                let (data, response) = try await session.data(for: request)

                guard let httpResponse = response as? HTTPURLResponse,
                      httpResponse.statusCode == 200 else {
                    return fallbackGigBenchmarks()
                }

                let parsed = parseBLSResponse(data: data)
                // BLS only gives us one data point; supplement with fallback platform data
                return parsed.isEmpty ? fallbackGigBenchmarks() : (parsed + fallbackPlatformBenchmarks())

            } catch {
                // Network error — fall through to fallback
            }
        }

        return fallbackGigBenchmarks()
    }

    /// Parses BLS JSON API response into `GigBenchmark` values.
    private func parseBLSResponse(data: Data) -> [GigBenchmark] {
        // BLS response structure:
        // { "Results": { "series": [{ "seriesID": "...", "data": [{ "year": "2026", "value": "28.50" }] }] } }
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let results = json["Results"] as? [String: Any],
              let series = results["series"] as? [[String: Any]],
              let firstSeries = series.first,
              let dataPoints = firstSeries["data"] as? [[String: Any]],
              let latest = dataPoints.first,
              let valueString = latest["value"] as? String,
              let hourlyRate = Double(valueString) else {
            return []
        }

        return [
            GigBenchmark(
                platform: "Transportation & Warehousing (BLS)",
                metric: "hourly_rate",
                nationalMedian: hourlyRate,
                percentile25: hourlyRate * 0.75,
                percentile75: hourlyRate * 1.30,
                lastUpdated: .now,
                source: "Bureau of Labor Statistics (CEU6562110008)"
            )
        ]
    }

    /// Returns platform-specific benchmarks from published gig economy reports.
    ///
    /// Sources:
    /// - Published gig economy driver surveys (2025)
    /// - Job listing salary aggregators
    /// - BLS Occupational Employment & Wage Statistics
    private func fallbackPlatformBenchmarks() -> [GigBenchmark] {
        let now = Date.now
        let sourceNote = "Published gig economy surveys, BLS OES"

        return [
            // -- Uber --
            GigBenchmark(
                platform: "Uber",
                metric: "hourly_rate",
                nationalMedian: 27.50,
                percentile25: 20.00,
                percentile75: 35.00,
                lastUpdated: now,
                source: sourceNote
            ),
            GigBenchmark(
                platform: "Uber",
                metric: "daily_earnings",
                nationalMedian: 195.0,
                percentile25: 130.0,
                percentile75: 280.0,
                lastUpdated: now,
                source: sourceNote
            ),
            GigBenchmark(
                platform: "Uber",
                metric: "fee_rate",
                nationalMedian: 0.25,
                percentile25: 0.20,
                percentile75: 0.30,
                lastUpdated: now,
                source: sourceNote
            ),

            // -- Lyft --
            GigBenchmark(
                platform: "Lyft",
                metric: "hourly_rate",
                nationalMedian: 24.00,
                percentile25: 18.00,
                percentile75: 32.00,
                lastUpdated: now,
                source: sourceNote
            ),
            GigBenchmark(
                platform: "Lyft",
                metric: "daily_earnings",
                nationalMedian: 175.0,
                percentile25: 120.0,
                percentile75: 250.0,
                lastUpdated: now,
                source: sourceNote
            ),
            GigBenchmark(
                platform: "Lyft",
                metric: "fee_rate",
                nationalMedian: 0.23,
                percentile25: 0.18,
                percentile75: 0.28,
                lastUpdated: now,
                source: sourceNote
            ),

            // -- DoorDash --
            GigBenchmark(
                platform: "DoorDash",
                metric: "hourly_rate",
                nationalMedian: 20.00,
                percentile25: 15.00,
                percentile75: 28.00,
                lastUpdated: now,
                source: sourceNote
            ),
            GigBenchmark(
                platform: "DoorDash",
                metric: "daily_earnings",
                nationalMedian: 140.0,
                percentile25: 90.0,
                percentile75: 200.0,
                lastUpdated: now,
                source: sourceNote
            ),

            // -- Instacart --
            GigBenchmark(
                platform: "Instacart",
                metric: "hourly_rate",
                nationalMedian: 17.50,
                percentile25: 13.00,
                percentile75: 24.00,
                lastUpdated: now,
                source: sourceNote
            ),

            // -- Uber Eats --
            GigBenchmark(
                platform: "Uber Eats",
                metric: "hourly_rate",
                nationalMedian: 18.00,
                percentile25: 13.00,
                percentile75: 25.00,
                lastUpdated: now,
                source: sourceNote
            ),

            // -- Grubhub --
            GigBenchmark(
                platform: "Grubhub",
                metric: "hourly_rate",
                nationalMedian: 17.00,
                percentile25: 12.00,
                percentile75: 24.00,
                lastUpdated: now,
                source: sourceNote
            ),

            // -- Amazon Flex --
            GigBenchmark(
                platform: "Amazon Flex",
                metric: "hourly_rate",
                nationalMedian: 22.00,
                percentile25: 18.00,
                percentile75: 28.00,
                lastUpdated: now,
                source: sourceNote
            ),

            // -- Shipt --
            GigBenchmark(
                platform: "Shipt",
                metric: "hourly_rate",
                nationalMedian: 16.00,
                percentile25: 12.00,
                percentile75: 22.00,
                lastUpdated: now,
                source: sourceNote
            ),

            // -- TaskRabbit --
            GigBenchmark(
                platform: "TaskRabbit",
                metric: "hourly_rate",
                nationalMedian: 28.00,
                percentile25: 20.00,
                percentile75: 45.00,
                lastUpdated: now,
                source: sourceNote
            ),

            // -- Spark (Walmart) --
            GigBenchmark(
                platform: "Spark",
                metric: "hourly_rate",
                nationalMedian: 19.00,
                percentile25: 14.00,
                percentile75: 26.00,
                lastUpdated: now,
                source: sourceNote
            )
        ]
    }

    /// Full fallback: all platform benchmarks (used when BLS API is entirely unavailable).
    private func fallbackGigBenchmarks() -> [GigBenchmark] {
        fallbackPlatformBenchmarks()
    }

    // MARK: - Economic Indicators

    /// Fetches macroeconomic indicators from the FRED API.
    ///
    /// API: `https://api.stlouisfed.org/fred/series/observations`
    /// Requires a free API key from https://fred.stlouisfed.org/docs/api/api_key.html
    ///
    /// Series fetched:
    /// - **CPIAUCSL**: Consumer Price Index (inflation measure)
    /// - **UNRATE**: Civilian Unemployment Rate
    /// - **PCE**: Personal Consumption Expenditures (consumer spending)
    func fetchEconomicIndicators() async -> [EconomicIndicator] {
        guard !fredAPIKey.isEmpty else {
            return fallbackEconomicIndicators()
        }

        let seriesConfigs: [(id: String, name: String, relevance: String)] = [
            ("CPIAUCSL", "Consumer Price Index (CPI)", "Higher CPI means your expenses (gas, food, supplies) are rising faster than usual"),
            ("UNRATE", "Unemployment Rate", "Lower unemployment can mean more ride demand but also more gig driver competition"),
            ("PCE", "Consumer Spending", "Rising consumer spending typically increases demand for delivery and ride services")
        ]

        var indicators: [EconomicIndicator] = []

        for config in seriesConfigs {
            if let indicator = await fetchFREDSeries(
                seriesID: config.id,
                name: config.name,
                relevance: config.relevance
            ) {
                indicators.append(indicator)
            }
        }

        return indicators.isEmpty ? fallbackEconomicIndicators() : indicators
    }

    /// Fetches a single FRED time series and returns the latest two observations.
    private func fetchFREDSeries(seriesID: String, name: String, relevance: String) async -> EconomicIndicator? {
        var components = URLComponents(string: fredBaseURL)
        components?.queryItems = [
            URLQueryItem(name: "series_id", value: seriesID),
            URLQueryItem(name: "api_key", value: fredAPIKey),
            URLQueryItem(name: "file_type", value: "json"),
            URLQueryItem(name: "sort_order", value: "desc"),
            URLQueryItem(name: "limit", value: "2")
        ]

        guard let url = components?.url else { return nil }

        do {
            let (data, response) = try await session.data(from: url)

            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else { return nil }

            return parseFREDResponse(data: data, name: name, relevance: relevance)

        } catch {
            return nil
        }
    }

    /// Parses a FRED JSON response into an `EconomicIndicator`.
    private func parseFREDResponse(data: Data, name: String, relevance: String) -> EconomicIndicator? {
        // FRED response structure:
        // { "observations": [{ "date": "2026-01-01", "value": "315.2" }, { "date": "2025-12-01", "value": "313.8" }] }
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let observations = json["observations"] as? [[String: Any]],
              observations.count >= 2,
              let currentStr = observations[0]["value"] as? String,
              let previousStr = observations[1]["value"] as? String,
              let current = Double(currentStr),
              let previous = Double(previousStr) else {
            return nil
        }

        let change = previous > 0 ? ((current - previous) / previous) * 100.0 : 0.0

        return EconomicIndicator(
            name: name,
            value: current,
            previousValue: previous,
            change: change,
            relevance: relevance,
            lastUpdated: .now
        )
    }

    /// Returns fallback economic indicators based on recent published data.
    ///
    /// Sources: FRED, BLS monthly reports, BEA consumer spending data.
    private func fallbackEconomicIndicators() -> [EconomicIndicator] {
        [
            EconomicIndicator(
                name: "Consumer Price Index (CPI)",
                value: 318.2,
                previousValue: 316.8,
                change: 0.44,
                relevance: "Higher CPI means your expenses (gas, food, supplies) are rising faster than usual",
                lastUpdated: .now
            ),
            EconomicIndicator(
                name: "Unemployment Rate",
                value: 4.1,
                previousValue: 4.2,
                change: -2.38,
                relevance: "Lower unemployment can mean more ride demand but also more gig driver competition",
                lastUpdated: .now
            ),
            EconomicIndicator(
                name: "Consumer Spending (PCE Index)",
                value: 19_850.0,
                previousValue: 19_600.0,
                change: 1.28,
                relevance: "Rising consumer spending typically increases demand for delivery and ride services",
                lastUpdated: .now
            )
        ]
    }

    // MARK: - Contextual Insights Generation

    /// Compares the user's personal financial data against external market data
    /// to produce actionable, contextualized insights.
    ///
    /// - Parameters:
    ///   - userIncome: User's total gross income (YTD or selected period)
    ///   - userExpenses: User's total expenses (YTD or selected period)
    ///   - userMileage: User's total miles driven
    ///   - userHourlyRate: User's calculated hourly rate (net income / estimated hours)
    ///   - platforms: List of platform names the user earns on
    /// - Returns: An array of `ContextualInsight` values sorted by confidence, then category.
    func generateContextualInsights(
        userIncome: Double,
        userExpenses: Double,
        userMileage: Double,
        userHourlyRate: Double,
        platforms: [String]
    ) -> [ContextualInsight] {
        var insights: [ContextualInsight] = []

        let dataFreshness = calculateDataFreshness()

        // 1. Hourly rate benchmarking per platform
        for platform in platforms {
            if let insight = generateHourlyRateBenchmark(
                platform: platform,
                userRate: userHourlyRate,
                confidence: dataFreshness
            ) {
                insights.append(insight)
            }
        }

        // 2. Gas price impact on mileage costs
        if let gasInsight = generateGasPriceInsight(
            userMileage: userMileage,
            confidence: dataFreshness
        ) {
            insights.append(gasInsight)
        }

        // 3. Tax update alerts
        for update in taxUpdates.prefix(3) {
            insights.append(generateTaxAlertInsight(update: update, confidence: dataFreshness))
        }

        // 4. Fee rate comparison per platform
        for platform in platforms {
            if let insight = generateFeeRateInsight(
                platform: platform,
                userIncome: userIncome,
                userExpenses: userExpenses,
                confidence: dataFreshness
            ) {
                insights.append(insight)
            }
        }

        // 5. Economic trend opportunities
        for indicator in economicIndicators {
            if let insight = generateEconomicInsight(
                indicator: indicator,
                confidence: dataFreshness
            ) {
                insights.append(insight)
            }
        }

        // 6. Expense ratio vs. market
        if let expenseInsight = generateExpenseRatioInsight(
            userIncome: userIncome,
            userExpenses: userExpenses,
            confidence: dataFreshness
        ) {
            insights.append(expenseInsight)
        }

        // Sort by confidence (fresh data first), then alphabetically by category
        return insights.sorted { lhs, rhs in
            if lhs.confidence != rhs.confidence {
                return lhs.confidence > rhs.confidence
            }
            return lhs.category.rawValue < rhs.category.rawValue
        }
    }

    // MARK: - Individual Insight Generators

    /// Compares the user's hourly rate against the national median for a given platform.
    private func generateHourlyRateBenchmark(
        platform: String,
        userRate: Double,
        confidence: Double
    ) -> ContextualInsight? {
        guard userRate > 0 else { return nil }

        // Find matching benchmark (case-insensitive partial match)
        guard let benchmark = benchmarks.first(where: {
            $0.metric == "hourly_rate" &&
            $0.platform.lowercased().contains(platform.lowercased())
        }) else { return nil }

        let difference = userRate - benchmark.nationalMedian
        let percentDiff = (difference / benchmark.nationalMedian) * 100.0

        let title: String
        let detail: String
        let icon: String

        if percentDiff > 10 {
            title = "Above Average on \(platform)"
            detail = String(format: "You earn $%.0f/hour vs the national median of $%.0f/hour for %@ drivers — you're in the top tier.",
                            userRate, benchmark.nationalMedian, platform)
            icon = "arrow.up.circle.fill"
        } else if percentDiff < -10 {
            title = "Below Average on \(platform)"
            detail = String(format: "You earn $%.0f/hour vs the national median of $%.0f/hour for %@ drivers. Consider optimizing routes or peak hours.",
                            userRate, benchmark.nationalMedian, platform)
            icon = "arrow.down.circle.fill"
        } else {
            title = "On Par with \(platform) Drivers"
            detail = String(format: "Your $%.0f/hour rate is right at the national median of $%.0f/hour for %@ drivers.",
                            userRate, benchmark.nationalMedian, platform)
            icon = "equal.circle.fill"
        }

        return ContextualInsight(
            title: title,
            detail: detail,
            icon: icon,
            category: .benchmark,
            dataSource: benchmark.source,
            confidence: confidence
        )
    }

    /// Generates an insight about gas price trends and their impact on the user's mileage costs.
    private func generateGasPriceInsight(
        userMileage: Double,
        confidence: Double
    ) -> ContextualInsight? {
        guard let gas = gasPrices, userMileage > 100 else { return nil }

        let monthlyMileageCost = (userMileage / 12.0) * gas.costPerMile
        let monthlyChange = gas.monthlyChange

        // Only generate if there's a meaningful price movement
        guard abs(monthlyChange) > 2.0 else { return nil }

        let direction = monthlyChange > 0 ? "up" : "down"
        let impact = abs(monthlyChange / 100.0) * monthlyMileageCost

        let title: String
        let icon: String
        let category: ContextualInsight.Category

        if monthlyChange > 0 {
            title = "Gas Prices Rising"
            icon = "fuelpump.fill"
            category = .costAlert
        } else {
            title = "Gas Prices Falling"
            icon = "fuelpump.fill"
            category = .opportunity
        }

        let detail = String(
            format: "Gas prices are %@ %.1f%% this month (national avg: $%.2f/gal). Your estimated monthly fuel cost impact: ~%@.",
            direction,
            abs(monthlyChange),
            gas.nationalAverage,
            CurrencyFormatter.format(impact)
        )

        return ContextualInsight(
            title: title,
            detail: detail,
            icon: icon,
            category: category,
            dataSource: "EIA (Energy Information Administration)",
            confidence: confidence
        )
    }

    /// Converts a tax update into a contextual insight card.
    private func generateTaxAlertInsight(update: TaxUpdate, confidence: Double) -> ContextualInsight {
        let detail: String

        switch update.impact {
        case .mileageRateChange(let oldRate, let newRate):
            detail = String(format: "The IRS mileage rate changed from $%.2f to $%.2f per mile. Make sure you're using the updated rate for deduction calculations.", oldRate, newRate)
        case .bracketChange(let description):
            detail = "Tax bracket update: \(description). Check your estimated quarterly payments."
        case .thresholdChange(let name, _, let newValue):
            detail = "\(name) is now \(CurrencyFormatter.format(newValue)). This may affect your reporting requirements."
        case .deadlineChange(let quarter, let newDate):
            let formatter = DateFormatter()
            formatter.dateStyle = .long
            detail = "\(quarter) estimated tax payment is due \(formatter.string(from: newDate)). Don't miss it to avoid penalties."
        case .newRule(let description):
            detail = description
        }

        return ContextualInsight(
            title: update.description,
            detail: detail,
            icon: "doc.text.fill",
            category: .taxAlert,
            dataSource: update.source,
            confidence: confidence
        )
    }

    /// Compares the user's effective fee rate on a platform against the benchmark.
    private func generateFeeRateInsight(
        platform: String,
        userIncome: Double,
        userExpenses: Double,
        confidence: Double
    ) -> ContextualInsight? {
        guard userIncome > 0 else { return nil }

        guard let benchmark = benchmarks.first(where: {
            $0.metric == "fee_rate" &&
            $0.platform.lowercased().contains(platform.lowercased())
        }) else { return nil }

        // User's implicit fee rate (platform fees as % of gross)
        // This is a rough proxy — actual fee data would come from IncomeEntry.fees
        let userFeeRate = userExpenses / userIncome

        let percentDiff = (userFeeRate - benchmark.nationalMedian) * 100.0

        guard abs(percentDiff) > 3.0 else { return nil }

        let title: String
        let detail: String

        if percentDiff > 0 {
            title = "Higher Than Average Fees on \(platform)"
            detail = String(format: "Your effective fee rate on %@ is ~%.0f%% vs the average of %.0f%%. Review if you're opting into optional programs that increase fees.",
                            platform, userFeeRate * 100, benchmark.nationalMedian * 100)
        } else {
            title = "Lower Fees on \(platform)"
            detail = String(format: "Your fee rate on %@ is ~%.0f%% vs the average of %.0f%% — you're keeping more of each dollar.",
                            platform, userFeeRate * 100, benchmark.nationalMedian * 100)
        }

        return ContextualInsight(
            title: title,
            detail: detail,
            icon: "percent",
            category: .benchmark,
            dataSource: benchmark.source,
            confidence: confidence
        )
    }

    /// Generates an insight from a macroeconomic indicator if the change is significant.
    private func generateEconomicInsight(
        indicator: EconomicIndicator,
        confidence: Double
    ) -> ContextualInsight? {
        // Only surface if the change is notable (> 1%)
        guard abs(indicator.change) > 1.0 else { return nil }

        let direction = indicator.change > 0 ? "up" : "down"
        let title = "\(indicator.name) is \(direction) \(String(format: "%.1f", abs(indicator.change)))%"

        return ContextualInsight(
            title: title,
            detail: indicator.relevance,
            icon: "chart.line.uptrend.xyaxis",
            category: .marketTrend,
            dataSource: "Federal Reserve Economic Data (FRED)",
            confidence: confidence
        )
    }

    /// Compares the user's expense-to-income ratio against typical gig worker ranges.
    private func generateExpenseRatioInsight(
        userIncome: Double,
        userExpenses: Double,
        confidence: Double
    ) -> ContextualInsight? {
        guard userIncome > 1000 else { return nil }

        let userRatio = userExpenses / userIncome

        // Typical gig worker expense ratios: 30-45% of gross income
        let typicalLow = 0.30
        let typicalHigh = 0.45

        if userRatio < typicalLow * 0.5 {
            return ContextualInsight(
                title: "Low Expense Ratio",
                detail: String(format: "Your expenses are only %.0f%% of income. Most gig workers report 30-45%%. You may be missing deductible expenses like mileage, phone, or supplies.",
                               userRatio * 100),
                icon: "exclamationmark.triangle.fill",
                category: .opportunity,
                dataSource: "IRS / Gig Economy Surveys",
                confidence: confidence
            )
        } else if userRatio > typicalHigh * 1.3 {
            return ContextualInsight(
                title: "High Expense Ratio",
                detail: String(format: "Your expenses are %.0f%% of income — above the typical 30-45%% range. Review your costs for potential savings.",
                               userRatio * 100),
                icon: "arrow.up.right.circle.fill",
                category: .costAlert,
                dataSource: "IRS / Gig Economy Surveys",
                confidence: confidence
            )
        }

        return nil
    }

    // MARK: - Data Freshness

    /// Calculates a 0.0–1.0 confidence score based on how recently data was fetched.
    ///
    /// - 1.0: Fetched within the last hour
    /// - 0.8: Fetched within the last 24 hours
    /// - 0.5: Fetched within the last 7 days
    /// - 0.3: Using fallback/stale data
    private func calculateDataFreshness() -> Double {
        guard let lastRefresh else { return 0.3 }

        let age = Date.now.timeIntervalSince(lastRefresh)

        switch age {
        case ..<3_600:       return 1.0   // < 1 hour
        case ..<86_400:      return 0.8   // < 24 hours
        case ..<604_800:     return 0.5   // < 7 days
        default:             return 0.3   // Stale
        }
    }

    // MARK: - Convenience Queries

    /// Returns the benchmark hourly rate for a specific platform, if available.
    func medianHourlyRate(for platform: String) -> Double? {
        benchmarks.first(where: {
            $0.metric == "hourly_rate" &&
            $0.platform.lowercased().contains(platform.lowercased())
        })?.nationalMedian
    }

    /// Returns the current gas cost per mile, using cached data or a reasonable default.
    var currentCostPerMile: Double {
        gasPrices?.costPerMile ?? (3.40 / averageGigVehicleMPG)
    }

    /// Returns the most recent tax updates, limited to a specified count.
    func recentTaxUpdates(limit: Int = 5) -> [TaxUpdate] {
        Array(taxUpdates.sorted { $0.effectiveDate > $1.effectiveDate }.prefix(limit))
    }

    /// Returns `true` if the cached data is stale and should be refreshed.
    var needsRefresh: Bool {
        guard let lastRefresh else { return true }
        return Date.now.timeIntervalSince(lastRefresh) >= cacheInterval
    }

    /// A human-readable string describing when data was last refreshed.
    var lastRefreshDescription: String {
        guard let lastRefresh else { return "Never" }

        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: lastRefresh, relativeTo: .now)
    }
}
